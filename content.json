{"pages":[{"title":"更换icarus主题记录","text":"[TOC] NexT: https://github.com/iissnan/hexo-theme-next icarus: https://github.com/ppoffice/hexo-theme-icarus 两者效果图如下: NexT icarus 相较NexT, icarus使用的人数没有很多, 想要改什么在网上搜到的基本都是关于NexT的 虽然icarus也提供了很多配置, 但还是有些地方想按照自己意思做些修改, 强迫症~ 有些无法通过配置完成的, 只能改源码了 作为后端开发前端知识匮乏, 还好icarus使用的是ejs, 一种模版语言, 类似以前用过的FreeMarker和Thymeleaf 变动日志主题配置文件_config.yml的更改不记录了, 可参考文档: Documentation 主要记录源码部分的变动如下: 修改navbar导航栏左边的logo配置方式因为不会设计Logo, 就改成”icon+文字”的方式, 并加入logo.img配置项 themes/hexo-theme-icarus/layout/common/navbar.ejs 修改navbar导航栏右边的搜索功能原版2.3.0只有一个小的搜索icon, 加入搜索输入框并嵌入搜索icon themes/hexo-theme-icarus/layout/common/navbar.ejs themes/hexo-theme-icarus/source/css/style.styl 修改个人信息页中的几个links原版是通过socialLinks动态配置的, 不支持微信, 码云, 微博这几个常用, 这里为了方便我使用&lt;a&gt;+&lt;img&gt;标签写死 themes/hexo-theme-icarus/layout/widget/profile.ejs 友情链接标题前加入icon, 为了好看 themes/hexo-theme-icarus/layout/widget/links.ejs 修改文章页(index页和post页)的文章时间加入判断, 如果是列表页显示例如几月前, 文章页显示具体日期, 例如2018-12-22 themes/hexo-theme-icarus/layout/common/article.ejs 修改文章详情页面不显示文章图片thumbnail在阅读文章时感觉有点花, 默认是index页和post页都会显示 themes/hexo-theme-icarus/layout/common/article.ejs 修改首页文章列表摘要信息不显示样式去掉Markdown生成的html标签, 类似简书上的文章排版, 整洁一点 themes/hexo-theme-icarus/layout/common/article.ejs 修改文章页面布局原版的主页和文章页都使用三栏布局, 在文章页阅读会显得内容很窄, 尤其是代码部分, 需要左右滚动, 故修改文章页为两栏布局 themes/hexo-theme-icarus/includes/helpers/layout.js themes/hexo-theme-icarus/layout/common/widget.ejs themes/hexo-theme-icarus/layout/layout.ejs themes/hexo-theme-icarus/source/css/style.styl 目录的开启方式改为默认就开启文章目录这样可以不用每个md文件都去写toc: true themes/hexo-theme-icarus/includes/helpers/config.js 修改开启目录后的显示问题默认目录在滚动文章时如果太长会显示不全, 所以增加目录粘性布局 themes/hexo-theme-icarus/layout/widget/toc.ejs 文章页增加版权声明 themes/hexo-theme-icarus/layout/common/article.ejs themes/hexo-theme-icarus/source/css/style.styl 修改底部footer的显示信息 themes/hexo-theme-icarus/layout/common/footer.ejs","link":"/README.html"}],"posts":[{"title":"TypeScript 环境","text":"配置TS环境到webpack使用ts-loader使用ts需要安装ts相关配置 1npm install typescript ts-loader --save-dev 生成ts的配置文件 1npx tsc --init 配置ts-loader 12345{ test:/\\.tsx?/, use: ['ts-loader'], exclude: /node_modules/} 将入口文件更改成ts文件 12let a:string = 'hello';console.log(a); 执行npm run dev发现已经可以正常的解析ts文件啦！ 使用 preset-typescript不需要借助typescript 1npm install @babel/preset-typescript 1234567891011121314151617{ \"presets\": [ [\"@babel/preset-env\",{ \"useBuiltIns\":\"usage\", \"corejs\":2 }], \"@babel/preset-react\", [\"@babel/preset-typescript\",{ \"allExtensions\": true }] ], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], [\"@babel/plugin-proposal-class-properties\",{\"loose\":true}], \"@babel/plugin-transform-runtime\" ]} 配置ts+react环境安装react相关模块 12npm i @babel/preset-react --save # 解析jsx语法npm i react @types/react @types/react-dom react react-dom typescript 1234567891011121314151617181920import React from 'react';import ReactDOM from 'react-dom';const state = {number:0};type State = Readonly&lt;typeof state&gt;;class Counter extends React.Component&lt;object,State&gt;{ state:State = state handleClick =()=&gt;{ this.setState({number:this.state.number+1}) } render(){ const {number} = this.state; return ( &lt;div&gt; &lt;button onClick={this.handleClick}&gt;点击&lt;/button&gt; {number} &lt;/div&gt; ) }}ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;,document.getElementById('root')); 配置ts+vue环境安装vue所需要的模块 12npm install vue-loader vue-template-compiler --save-devnpm install vue vue-property-decorator 配置ts-loader 12345678910{ test: /\\.tsx?/, use: { loader:'ts-loader', options: { appendTsSuffixTo: [/\\.vue$/], }, }, exclude: /node_modules/} 使用vue-loader插件 12const VueLoaderPlugin = require('vue-loader/lib/plugin');new VueLoaderPlugin(); 配置解析.vue文件 1234{ test:/\\.vue$/, use:'vue-loader'} 增加vue-shims.d.ts，可以识别.vue文件 1234declare module &apos;*.vue&apos; { import Vue from &apos;vue&apos;; export default Vue;} index.tsx文件 12345import Vue from 'vue';import App from './App.vue';let vm = new Vue({ render:h=&gt;h(App)}).$mount('#root') App.vue文件 123456789101112&lt;template&gt; &lt;div&gt; &lt;div v-for=\"(todo,index) in todos\" :key=\"index\"&gt;{{todo}}&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import {Component,Vue} from 'vue-property-decorator';@Componentexport default class Todo extends Vue{ public todos = ['香蕉','苹果','橘子']}&lt;/script&gt;","link":"/2019/11/02/TypeScript 环境/"},{"title":"eslint 集成到 webpack","text":"安装依赖1npm install eslint -D 如果需要支持 es6 语法 1npm install babel-eslint -D eslint 配置12345678910111213{ \"parser\": \"babel-eslint\", // 支持解析 es6 语法校验 \"rules\": { \"semi\": [ // 结尾分号控制 \"error\", \"always\" // 必须加分号 ], \"quotes\": [ // 引号控制 \"error\", \"single\" // 必须是单引号 ] }} webpack 配置12345678910111213141516171819202122232425{ module: { rules: [ { test: /\\.js$/, enforce: 'pre', use: 'eslint-loader', include: resolve('src'), exclude: resolve('node_modules') } ] }, plugins: [ new webpack.LoaderOptionsPlugin({ options: { eslint: { configFile: resolve('.eslintrc.json'), failOnWarning: true, // eslint 报 warning 就停止 webpack 编译 failOnError: false, // eslint 报 error 就停止 webpack 编译 cache: true // 开启缓存，加快编译速度 } } }) ]} 小结webpack在配置eslint-loader的时候，有一个 inforce: 'pre' 的配置项。这个和webpack的loader的执行顺序有关，关于这个就是另一个话题了。","link":"/2019/10/19/eslint-集成到-webpack/"},{"title":"webpack 优化","text":"上一章节我们已经掌握了webpack常见的所有配置 这一节我们来看看如何实现webpack中的优化，我们先来编写最基本的webpack配置，然后依次实现各种优化！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const path = require(\"path\");module.exports = mode =&gt; { return { mode: mode, entry: \"./src/main.js\", output: { filename: \"bundle.js\", path: path.resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: \"file-loader\" }, { test: /\\.js$/, use: \"babel-loader\" // .babelrc已经配置支持react }, { test: /\\.css$/, use: [ mode !== \"development\" ? MiniCssExtractPlugin.loader : \"style-loader\", \"css-loader\" ] } ] }, plugins: [ new PurgecssPlugin({ paths: glob.sync(`${path.join(__dirname, \"src\")}/**/*`, { nodir: true }) // 不匹配目录，只匹配文件 }), mode !== \"development\" &amp;&amp; new MiniCssExtractPlugin({ filename: \"css/[name].css\" }), new HtmlWebpackPlugin({ template: \"./src/template.html\", filename: \"index.html\" }) ].filter(Boolean) };}; .babelrc配置文件 123456{ \"presets\": [ \"@babel/preset-env\", \"@babel/preset-react\" ]} 1.删除无用的Css样式先来看编写的代码 12345import './style.css'import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;div&gt;hello&lt;/div&gt;,document.getElementById('root')); 1234567body{ background: red}.class1{ background: red} 这里的.class1显然是无用的，我们可以搜索src目录下的文件，删除无用的样式 1234567const glob = require('glob');const PurgecssPlugin = require('purgecss-webpack-plugin');// 需要配合mini-css-extract-plugin插件mode !== \"development\" &amp;&amp; new PurgecssPlugin({ paths: glob.sync(`${path.join(__dirname, \"src\")}/**/*`, { nodir: true }) // 不匹配目录，只匹配文件}), 注意：动态 class 会被删掉 2.图片压缩插件将打包后的图片进行优化 1npm install image-webpack-loader --save-dev 在file-loader之前使用压缩图片插件 12345678910111213141516171819202122{ loader: \"image-webpack-loader\", options: { mozjpeg: { progressive: true, quality: 65 }, optipng: { enabled: false, }, pngquant: { quality: [0.90, 0.95], speed: 4 }, gifsicle: { interlaced: false, }, webp: { quality: 75 } }} 可以发现图片大小是有了明显的变化 3.CDN加载文件我们希望通过cdn的方式引入资源 1234const AddAssetHtmlCdnPlugin = require('add-asset-html-cdn-webpack-plugin')new AddAssetHtmlCdnPlugin(true,{ 'jquery':'https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js'}) 但是在代码中还希望引入jquery来获得提示 12import $ from 'jquery'console.log('$',$) 但是打包时依然会将jquery进行打包 123externals:{ 'jquery':'$'} 那么就在配置文件中设置 externals ，标注jquery是外部的，这样打包时就不会将jquery进行打包了 4.Tree-shaking &amp;&amp; Scope-Hoisting4.1 Tree-shaking顾名思义就是将没用的内容摇晃掉,来看下面代码 main.js 12import { minus } from \"./calc\";console.log(minus(1,1)); calc.js 123456789import {test} from './test';export const sum = (a, b) =&gt; { return a + b + 'sum';};export const minus = (a, b) =&gt; { return a - b + 'minus';}; test.js 1234export const test = ()=&gt;{ console.log('hello')}console.log(test()); 观察上述代码其实我们主要使用minus方法,test.js代码属于副作用代码! 默认mode:production时，会自动tree-shaking,但是副作用代码却不会清除掉。打包后'hello'依然会被打印出来,这时候我们需要在package.json中，配置不使用副作用。 1\"sideEffects\":false, 这样设置后，副作用代码就不会被打包，但是对于css文件就会有影响了，因为我们 css 也是通过import './style.css'来引入的。 这里重点就来了,tree-shaking主要针对es6模块,我们可以使用require语法导入css,但是这样用起来有点格格不入,所以我们可以配置css文件不是副作用 123\"sideEffects\":[ \"**/*.css\"] 在开发环境下默认tree-shaking不会生效, 可以配置标识提示只能在开发模式下使用。 123optimization:{ usedExports:true } 4.2 Scope Hoisting作用域提升,可以减少代码体积，节约内存。（webpack自带了，无需配置） 12345678910let a = 1;let b = 2;let c = 3;let d = a + b + cexport default d;// 引入dimport d from './d';console.log(d) 最终打包后的结果会变成 console.log(6) 代码量明显减少 减少多个函数后内存占用也将减少 5.DllPlugin &amp;&amp; DllReferencePlugin每次构建时第三方模块都需要重新构建，这个性能消耗比较大，我们可以先把第三方库打包成动态链接库，以后构建时只需要查找构建好的库就好了，这样可以大大节约构建时间 1234import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;h1&gt;hello&lt;/h1&gt;,document.getElementById('root')) 5.1 DllPlugin 这里我们可以先将react、react-dom单独进行打包 单独打包创建webpack.dll.js 1234567891011121314151617181920const path = require('path');const DllPlugin = require('webpack/lib/DllPlugin');module.exports = { entry:['react','react-dom'], mode:'production', output:{ filename:'react.dll.js', path:path.resolve(__dirname,'dll'), library:'react' }, plugins:[ new DllPlugin({ name:'react', // 生成的第三方模块映射表，便于快速查找 path:path.resolve(__dirname,'dll/manifest.json') }) ]} 执行&quot;webpack --config webpack.dll.js命令，可以看到dll目录下创建了两个文件分别是manifest.json,react.dll.js 关系是这个酱紫的，到时候我们会通过manifest.json找到react.dll.js文件中的模块进行加载 5.2 DllReferencePlugin在我们的项目中可以引用刚才打包好的动态链接库 1234567891011121314const DllReferencePlugin = require('webpack/lib/DllReferencePlugin');const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');plugins: [ // 构建时会引用动态链接库的内容 new DllReferencePlugin({ manifest:path.resolve(__dirname,'dll/manifest.json') }), // 需要手动引入react.dll.js new AddAssetHtmlWebpackPlugin( { filepath: path.resolve(__dirname,'dll/react.dll.js') } )] 使用DllPlugin可以大幅度提高构建速度 6.动态加载实现点击后动态加载文件 12345678let btn = document.createElement('button');btn.innerHTML = '点击加载视频';btn.addEventListener('click',()=&gt;{ import('./video').then(res=&gt;{ console.log(res.default); });});document.body.appendChild(btn); 给动态引入的文件增加名字 12345678output:{ chunkFilename:'[name].min.js'}// 下面的注释是魔术字符串import(/* webpackChunkName: \"video\" */ './video').then(res=&gt;{ console.log(res.default);}) 这样打包后的结果最终的文件就是 video.min.js 7.打包文件分析工具安装webpack-bundle-analyzer插件 1npm install --save-dev webpack-bundle-analyzer 使用插件 123const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');mode !== \"development\" &amp;&amp; new BundleAnalyzerPlugin() 默认就会展现当前应用的分析图表 8.SplitChunks 注意：不要和动态链接库的配置一起写，会有冲突。一般动态链接库在开发模式下用，代码分割在生产模式下用。 我们在来看下SplitChunks这个配置，他可以在编译时抽离第三方模块、公共模块 将项目配置成多入口文件 1234entry:{ a:'./src/a.js', b:'./src/b.js'} 我们让a,b两个模块同时引用jquery, 别忘了去掉之前的externals配置 SplitChunks插件的默认配置 123456789101112131415161718192021222324252627282930313233343536373839optimization: { splitChunks: { chunks: 'async', // 分割异步模块。可选参数：inital 同步、async 异步、all 所有 minSize: 30000, // 分割的文件最小大小，单位：字节 maxSize: 0, minChunks: 1, // 引用次数 maxAsyncRequests: 5, // 最大异步请求数，简单来说，不能用超过五个 script 加载 maxInitialRequests: 3, // 最大初始化请求数 automaticNameDelimiter: '~', // 抽离的命名分隔符 automaticNameMaxLength: 30, // 名字最大长度 name: true, /* 缓存组：主要用于匹配抽离模块的位置。 下面的 vendors 配置，如果在 node_modules 里找不到，就会去 default 里找 */ cacheGroups: { // 指定分割 react、react-dom react: { test: /[\\\\/]node_modules[\\\\/](react)|(react-dom)/, priority: 1 // 优先级 } , // 分割第三方 vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10 }, // 再分割自定义模块 default: { minChunks: 2, // 覆盖原来的配置，至少引用2次才分割 priority: -20, reuseExistingChunk: true } } }} 我们将async改为initial 我们在为每个文件动态导入lodash库,并且改成async 1import('lodash') 为每个入口引入c.js,并且改造配置文件 123456789101112131415splitChunks: { chunks: 'all', name: true, cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10 }, default: { minSize:1, // 不是第三方模块，被引入两次也会被抽离 minChunks: 2, priority: -20, } }} 这样再反过来看chunks的参数是不是就了然于胸啦！ 9.热更新模块热替换（HMR - Hot Module Replacement）是 webpack 提供的最有用的功能之一。它允许在运行时替换，添加，删除各种模块，而无需进行完全刷新重新加载整个页面 保留在完全重新加载页面时丢失的应用程序的状态 只更新改变的内容，以节省开发时间 调整样式更加快速，几乎等同于就在浏览器调试器中更改样式 启用热更新，默认样式可以支持热更新，如果不支持热更新则采用强制刷新 1234devServer:{ hot:true}new webpack.NamedModulesPlugin(), 让js支持热更新 12345import sum from './sum';console.log(sum(1,2));if(module.hot){ // 如果支持热更新 module.hot.accept(); // 当入口文件变化后重新执行当前入口文件} 10.IgnorePlugin忽略 import和require语法 1new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) 11.费时分析可以计算每一步模块执行的运行速度 12345const SpeedMeasureWebpackPlugin = require('speed-measure-webpack-plugin');const smw = new SpeedMeasureWebpackPlugin();// 包裹所有配置module.exports = smw.wrap({}); 12.noParsemodule.noParse，对类似jq这类依赖库，内部不会引用其他库，我们在打包的时候就没有必要去解析，这样能够增加打包速率 1noParse:/jquery/ 13.resolve12345resolve: { extensions: [\".js\",\".jsx\",\".json\",\".css\"], alias:{}, // 配置别名 modules:['node_modules']}, 14.include/exclude在使用loader时,可以指定哪些文件不通过loader,或者指定哪些文件通过loader 123456{ test: /\\.js$/, use: \"babel-loader\", // include:path.resolve(__dirname,'src'), exclude:/node_modules/}, 15.多线程打包多线程打包，我们可以将不同的逻辑交给不同的线程来处理。 注意：当项目比较大的时候使用比较和好，因为分配线程本身就需要消耗内存的，如果项目规模很小，一个线程就足够了，那么用更多的线程反而更加浪费。 1npm install --save-dev happypack 使用插件 12345678910111213141516171819202122232425const HappyPack = require('happypack');rules:[ { test: /\\.js$/, use: 'happypack/loader?id=jsx' }, { test: /\\.less$/, use: 'happypack/loader?id=styles' },]new HappyPack({ id: 'jsx', threads: 4, loaders: [ 'babel-loader' ]}),new HappyPack({ id: 'styles', threads: 2, loaders: [ 'style-loader', 'css-loader', 'less-loader' ]})","link":"/2019/11/02/webpack 优化/"},{"title":"使用 vuex","text":"官方定义： Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 注入 vuex12345import store from './store'new Vue({ store}) store.js 123456789101112import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store({ state: { msg: 'hello world' }, mutations: {}, actions: {}}) 获取状态 这样在任何一个组件里，都可以这样获取到这个 msg 123456&lt;template&gt; &lt;div class=\"about\"&gt; &lt;h1&gt;This is an about page&lt;/h1&gt; &lt;h2&gt;{{$store.state.msg}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt; 修改状态让 mutations 提供一个修改状态的方法 12345mutations: { setMsg(state, newMsg) { state.msg = newMsg }} 再让 actions 来提交修改的请求 12345actions: { setMsg ({ commit }) { commit('setMsg', 'hello') }} 修改的动作，在其它组件里去触发 1234567891011121314&lt;template&gt; &lt;div class=\"about\"&gt; &lt;h1&gt;This is an about page&lt;/h1&gt; &lt;h2&gt;{{$store.state.msg}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { mounted () { this.$store.dispatch('setMsg') }}&lt;/script&gt; 思考上例属于简单的状态管理，state在存放状态、mutations提供了修改状态的方法、actions负责触发修改状态的方法，并提交修改的数据；上例actions里是手动修改的数据，工作中应该是提交请求的数据。但是上例中有个明显的问题，谁都可以修改（dispatch）状态。 命名空间如果项目足够复杂，那么可以使用 vuex 提供的命名空间来修改状态。使用的前提还需要使用 vuex的modules。modules是个对象，其结构也是由state、 mutations 、actions 组成。区别是它多了一个 namespaced 属性，以此来使用命名空间。 修改状态的三种方法dispatch先把原来写的内容提取到一个modules里 store.js 1234567891011import Vue from 'vue'import Vuex from 'vuex'import home from './modules/home'Vue.use(Vuex)export default new Vuex.Store({ modules: { home }}) ./modules/home.js 12345678910111213141516export default { namespaced: true, state: { msg: 'hello world' }, actions: { setMsg({ commit }) { commit('setMsg', 'hello') } }, mutations: { setMsg(state, newMsg) { state.msg = newMsg } }} 最后取状态和修改状态 1234567891011121314&lt;template&gt; &lt;div class=\"about\"&gt; &lt;h1&gt;This is an about page&lt;/h1&gt; &lt;h2&gt;{{$store.state.home.msg}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { mounted () { this.$store.dispatch('home/setMsg') }}&lt;/script&gt; 观察最后修改时和之前的不同，无非是取状态和修改状态都多了一层home ，提高了一定的使用门槛。尽管这样，但至少可以识别操作的是哪个模块的状态。 上例再通过modules修改 状态还有另一种等价的写法 mapActions12345678910111213141516171819&lt;template&gt; &lt;div class=\"about\"&gt; &lt;h1&gt;This is an about page&lt;/h1&gt; &lt;h2&gt;{{$store.state.home.msg}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapActions } from 'vuex' export default { methods: { ...mapActions('home', ['setMsg']) }, mounted () { this.setMsg() }}&lt;/script&gt; mapActions执行完后返回的是一个对象，通过扩展云算法展开后，会在当前实例里添加一个setMsg方法。调用这个方法就会触发状态的修改。 createNamespacedHelpers上面两个方法都有一个很明显的问题，如果在当前组件里，需要修改的状态有很多个。那么就意味着有很多层home。通过vuex的createNamespacedHelpers方法，可以很友好的解决这个问题。 1234567891011121314151617181920&lt;template&gt; &lt;div class='about'&gt; &lt;h1&gt;This is an about page&lt;/h1&gt; &lt;h2&gt;{{$store.state.home.msg}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { createNamespacedHelpers } from 'vuex'const { mapActions } = createNamespacedHelpers('home')export default { methods: { ...mapActions(['setMsg']) }, mounted () { this.setMsg() }}&lt;/script&gt; 简化取值之前的例子一直没有提到取值的问题，实际工作中也不推荐那么去做；vuex提供了一个mapState的方法，可以简化取值。 1234567891011121314151617181920212223&lt;template&gt; &lt;div class='about'&gt; &lt;h1&gt;This is an about page&lt;/h1&gt; &lt;h2&gt;{{msg}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { createNamespacedHelpers } from 'vuex'const { mapActions, mapState } = createNamespacedHelpers('home')export default { computed: { ...mapState(['msg']) }, methods: { ...mapActions(['setMsg']) }, mounted () { this.setMsg() }}&lt;/script&gt; 提取变量回忆一下 setMsg这个字眼出现的次数，在组件里使用出现过，在store或modules里出现过。这时提倡的做法，就是将这个setMsg提取出来，用一个常量保存； ./store/action-type.js 1export const SET_MSG = 'setMsg' 使用的时候，尽量避免直接使用setMsg，这样便于自己或其他人去维护。 总结vuex的便利性不言而喻，根据项目的复杂度，它提供了渐进增强的方案。当项目很简单时，不用modules就能解决基本需求。如果复杂度上升了，modules自然是不二选择。如果模块儿的个数并不多，大可只用 dispatch。即便模块儿多了起来，createNamespacedHelpers也为后续工作铺好了路。","link":"/2019/11/04/使用 vuex/"},{"title":"搭建 webpack 配置","text":"1.什么是Webpack？webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler),当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle 使用Webpack作为前端构建工具： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 在webpack应用中有两个核心: 模块转换器，用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块 扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 2.初始化项目123├── src # 源码目录│ ├── a-module.js│ └── index.js 编写 a-module.js 1module.exports = 'hello'; 编写 index.js 12let a = require('./a-module');console.log(a); 这里我们使用CommonJS模块的方式引入，这种方式默认在浏览器上是无法运行的，我们希望通过 webpack 来进行打包！ 3.webpack快速上手3.1 安装12npm init -ynpm install webpack webpack-cli --save-dev webpack默认支持0配置,配置scripts脚本 123\"scripts\": { \"build\": \"webpack\"} 执行npm run build,默认会调用 node_modules/.bin下的webpack命令，内部会调用webpack-cli解析用户参数进行打包。默认会以 src/index.js 作为入口文件。 这里也可以使用npx webpack,npx 是 5.2版本之后npm提供的命令可以执行.bin下的可执行文件 我们可以发现已经产生了dist目录，此目录为最终打包出的结果。main.js可以在html中直接引用,这里还提示我们默认mode 为production 3.2 webpack.config.js我们打包时一般不会采用0配置，webpack在打包时默认会查找当前目录下的 webpack.config.js or webpackfile.js 文件。 通过配置文件进行打包 12345678const path = require('path');module.exports = { entry: './src/index.js', output: { filename:'bundle.js', // 打包出的结果文件 path:path.resolve(__dirname,'dist') // 打包到dist目录下 }} 3.3 配置打包的mode我们需要在打包时提供mode属性来区分是开发环境还是生产环境,来实现配置文件的拆分 1234├── build│ ├── webpack.base.js│ ├── webpack.dev.js│ └── webpack.prod.js 我们可以通过指定不同的文件来进行打包 配置scripts脚本 1234\"scripts\": { \"build\": \"webpack --config ./build/webpack.prod\", \"dev\": \"webpack --config ./build/webpack.dev\"} 可以通过 config 参数指定,使用哪个配置文件来进行打包 通过env参数区分 1234\"scripts\": { \"build\": \"webpack --env.production --config ./build/webpack.base\", \"dev\": \"webpack --env.development --config ./build/webpack.base\"} 改造webpack.base文件默认导出函数，会将环境变量传入到函数的参数中 123module.exports = (env)=&gt;{ console.log(env); // { development: true }} 合并配置文件 我们可以判断当前环境是否是开发环境来加载不同的配置,这里我们需要做配置合并安装webpack-merge: 1npm install webpack-merge --save-dev webpack.dev配置 123module.exports = { mode:'development'} webpack.prod配置 123module.exports = { mode:'production'} webpack.base配置 12345678910111213141516171819202122const path = require('path');const merge = require('webpack-merge');// 开发环境const dev = require('./webpack.dev');// 生产环境const prod = require('./webpack.prod');const base = { // 基础配置 entry:'./src/index.js', output:{ filename:'bundle.js', path:path.resolve(__dirname,'../dist') }}module.exports = (env) =&gt;{ if(env.development){ return merge(base,dev); }else{ return merge(base,prod) }} 后续的开发中，我们会将公共的逻辑放到base中,开发和生产对的配置也分别进行存放！ 4.webpack-dev-server配置开发服务器，可以在实现在内存中打包,并且自动启动服务 1npm install webpack-dev-server --save-dev 1234\"scripts\": { \"build\": \"webpack --env.production --config ./build/webpack.base\", \"dev\": \"webpack-dev-server --env.development --config ./build/webpack.base\"} 通过执行npm run dev来启启动开发环境 默认会在当前根目录下启动服务 配置开发服务的配置 12345678910const path = require('path')module.exports = { mode:'development', devServer:{ // 更改静态文件目录位置 contentBase:path.resolve(__dirname,'../dist'), compress:true, // 开启gzip port:3000, // 更改端口号 }} 5.打包Html插件5.1 单入口打包自动产生html，并引入打包后的文件 编辑webpack.base文件 1234567891011const HtmlWebpackPlugin = require('html-webpack-plugin');plugins:[ new HtmlWebpackPlugin({ filename:'index.html', // 打包出来的文件名 template:path.resolve(__dirname,'../public/index.html'), hash:true, // 在引用资源的后面增加hash戳 minify:{ removeAttributeQuotes:true // 删除属性双引号 } })] 5.2 多入口打包根据不同入口 生成多个js文件，引入到不同html中 123── src ├── entry-1.js └── entry-2.js 多入口需要配置多个entry 123456789entry:{ jquery:['jquery'], // 打包jquery entry1:path.resolve(__dirname,'../src/entry-1.js'), entry2:path.resolve(__dirname,'../src/entry-2.js')},output:{ filename:'[name].js', path:path.resolve(__dirname,'../dist')}, 产生多个Html文件 123456789101112131415161718192021new HtmlWebpackPlugin({ filename:'index.html', template:path.resolve(__dirname,'../public/template.html'), hash:true, minify:{ removeAttributeQuotes:true }, chunks:['jquery','entry1'], // 引入的chunk 有jquery,entry}),new HtmlWebpackPlugin({ filename:'login.html', template:path.resolve(__dirname,'../public/template.html'), hash:true, minify:{ removeAttributeQuotes:true }, inject:false, // inject 为false表示不注入js文件 // 默认打包后引入文件的顺序，是根据入口的顺序来的。可以在这里设置 chunksSortMode，指定顺序为 chunks 里的顺序来 chunksSortMode:'manual', chunks:['entry2','jquery']}) 以上的方式不是很优雅，每次都需要手动添加HtmlPlugin应该动态产生html文件，可以像这样优化: 1234567891011121314151617181920212223let htmlPlugins = [ { entry: \"entry1\", html: \"index.html\" }, { entry: \"entry2\", html: \"login.html\" }].map( item =&gt; new HtmlWebpackPlugin({ filename: item.html, template: path.resolve(__dirname, \"../public/template.html\"), hash: true, minify: { removeAttributeQuotes: true }, chunks: [\"jquery\", item.entry] }));plugins: [...htmlPlugins] 6.清空打包结果可以使用clean-webpack-plugin手动清除某个文件夹内容: 安装 1npm install --save-dev clean-webpack-plugin 12345const { CleanWebpackPlugin } = require('clean-webpack-plugin');new CleanWebpackPlugin({ // 清空匹配的路径 cleanOnceBeforeBuildPatterns: [path.resolve('xxxx/*'),'**/*'],}) 这样就可以清空指定的目录了,我们可以看到webpack插件的基本用法就是 new Plugin并且放到plugins中 Webpack中必须掌握的配置loader主要用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块！通过使用不同的Loader，Webpack可以把不同的文件都转成JS文件,比如CSS、ES6/7、JSX等。 我们来看看这些我们必须掌握的loader! 1.配置 loader1.1 loader的使用 test：匹配处理文件的扩展名的正则表达式 use：loader名称，就是你要使用模块的名称 include/exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹 options:为loaders提供额外的设置选项 默认loader的顺序是从下到上、从右向左执行，当然执行顺序也可以手动定义的，接下来我们依次介绍常见的loader，来感受loader的魅力! 我们基于这个基础配置来继续编写: 123456789101112131415161718192021222324252627282930313233const path = require(\"path\");const dev = require(\"./webpack.dev\");const prod = require(\"./webpack.prod\");const merge = require(\"webpack-merge\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const { CleanWebpackPlugin } = require('clean-webpack-plugin');const base = { entry:'./src/index.js', output: { filename: \"[name].js\", path: path.resolve(__dirname, \"../dist\") }, plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, \"../public/template.html\"), hash: true, minify: { removeAttributeQuotes: true } }), new CleanWebpackPlugin({ cleanOnceBeforeBuildPatterns: [path.resolve('xxxx/*'),'**/*'], }), ]};module.exports = env =&gt; { if (env.development) { return merge(base, dev); } else { return merge(base, prod); }}; 2.处理CSS文件2.1 解析css样式我们在js文件中引入css样式！ 1import './index.css'; 再次执行打包时，会提示css无法解析 123ERROR in ./src/index.css 1:4Module parse failed: Unexpected token (1:4)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders 安装loader 1npm install style-loader css-loader --save-dev 12345678module: { rules: [ { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] } ]} 2.2 抽离样式文件默认只在打包时进行样式抽离 123456789module.exports = env =&gt; { let isDev = env.development; const base = {/*source...*/} if (isDev) { return merge(base, dev); } else { return merge(base, prod); }}; 安装抽离插件 1npm install mini-css-extract-plugin --save-dev 配置抽离插件 12345678910111213141516171819{ module: { rules: [ { test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"css-loader\" ].filter(Boolean) } ] }, plugins: [ !isDev &amp;&amp; new MiniCssExtractPlugin({ filename: \"css/[name].css\" }) ].filter(Boolean)} plugins 里的成员，不能是一个布尔值，否则会报错；而上面的配置在开发环境下会是个 false 。那么我们就可以通过数组的 filter 方法做个简单的过滤处理。 最终文件配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const path = require(\"path\");const dev = require(\"./webpack.dev\");const prod = require(\"./webpack.prod\");const merge = require(\"webpack-merge\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = env =&gt; { let isDev = env.development; const base = { entry: \"./src/index.js\", output: { filename: \"[name].js\", path: path.resolve(__dirname, \"../dist\") }, module: { rules: [ { test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"css-loader\" ].filter(Boolean) } ] }, plugins:[ !isDev &amp;&amp; new MiniCssExtractPlugin({ filename: \"css/[name].css\" }), new HtmlWebpackPlugin({ filename: \"index.html\", template: path.resolve(__dirname, \"../public/template.html\"), hash: true, minify: { removeAttributeQuotes: true } }), ].filter(Boolean) }; if (isDev) { return merge(base, dev); } else { return merge(base, prod); }}; 2.3 css预处理器不同的css预处理器要安装不同的loader来进行解析 预处理器 需要的 loader sass sass-loader、node-sass less less-loader、less stylus stylus-loader、stylus 使用sass 123456789{ test:/\\.scss$/, use:[ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"css-loader\", \"sass-loader\" ].filter(Boolean)} 在css文件中可能会使用@import语法引用css文件,被引用的css文件中可能还会导入 scss 。这样在编译 css的时候，scss 代码不会被编译；可以这么配置：1234567891011121314{ test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', { loader:\"css-loader\", options:{ importLoaders: 1 } }, \"sass-loader\" ].filter(Boolean)}, 把 css-loader 的用法改成对象，在配置里面设置 importLoaders 。表示在使用 css-loader 编译之前，如果 css 里面使用了 @import 语法引入了一个 scss 文件，就先用 1 个放置在在后面的 loader 先编译一次；也就用 sass-loader 编译一次。再继续用 css-loader 编译，就会编译引入的那个 scss。 2.4 处理样式前缀使用postcss-loader增加样式前缀 1npm install postcss-loader autoprefixer 在处理css前先增加前缀 1234567891011121314{ test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', { loader:\"postcss-loader\", options:{ plugins:[require('autoprefixer')] } }, \"sass-loader\" ].filter(Boolean)} 或者也可以创建postcss的配置文件postcss.config.js 12345module.exports = { plugins:[ require('autoprefixer') ]} 然后 123456789{ test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"postcss-loader\", \"sass-loader\" ].filter(Boolean)} 可以配置浏览器的兼容性范围，在项目根目录下建一个 .browserslistrc 文件： 1cover 99.5% 这里表示覆盖的浏览器范围 2.5 css压缩在生产环境下我们需要压缩css文件,配置minimizer选项,安装压缩插件 1npm i optimize-css-assets-webpack-plugin terser-webpack-plugin --save-dev 在webpack.prod.js文件中配置压缩 12345const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');const TerserJSPlugin = require('terser-webpack-plugin');optimization:{ minimizer:[new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})]} 2.6 文件指纹 Hash整个项目的hash值 chunkhash 根据入口产生hash值 contentHash 根据每个文件的内容产生的hash值 我们可以合理的使用hash戳，进行文件的缓存 123!isDev &amp;&amp; new MiniCssExtractPlugin({ filename: \"css/[name].[contentHash].css\"}) 3.处理文件类型3.1 处理引用的图片1234import logo from './webpack.png';let img = document.createElement('img');img.src = logo;document.body.appendChild(img); 使用file-loader,会将图片进行打包，并将打包后的路径返回 123456789{ test:/\\.jpe?g|png|gif/, use:{ loader:'file-loader', options:{ name:`img/[name].[ext]` } }} 3.2 处理icon二进制文件也是使用file-loader来打包 123456{ test:/woff|ttf|eot|svg|otf/, use:{ loader:'file-loader' }} 3.3 转化成base64使用url-loader将满足条件的图片转化成base64,不满足条件的url-loader会自动调用file-loader来进行处理 12345678910{ test:/\\.jpe?g|png|gif/, use:{ loader:'url-loader', options:{ limit:100*1024, name:`img/[name].[ext]` } }} 4.处理JS模块4.1 将es6代码编译成es5代码代码的转化工作要交给babel来处理 1npm install @babel/core @babel/preset-env babel-loader --save-dev @babel/core是babel中的核心模块，@babel/preset-env 的作用是es6转化es5插件的插件集合，babel-loader是webpack和loader的桥梁。 123const sum = (a, b) =&gt; { return a + b;}; 增加babel的配置文件 .babelrc 12345{ \"presets\": [ [\"@babel/preset-env\"] ]} 配置loader 123module: { rules: [{ test: /\\.js$/, use: \"babel-loader\" }]}, 现在打包已经可以成功的将es6语法转化成es5语法！ 4.2 解析装饰器1npm i @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators --save-dev 1234\"plugins\": [ [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], [\"@babel/plugin-proposal-class-properties\",{\"loose\":true}]] legacy:true表示继续使用装饰器装饰器，loose为false时会采用Object.defineProperty定义属性 Plugin会运行在Preset之前 Plugin 会从第一个开始顺序执行，Preset则是相反的 4.3 polyfill根据.browserslistrc文件，转化使用到的浏览器api 123456\"presets\": [ [\"@babel/preset-env\",{ \"useBuiltIns\":\"usage\", // 按需加载 \"corejs\":2 // corejs 替代了以前的pollyfill }]] 安装corejs 1npm install core-js@2 --save 使用transform-runtimeA plugin that enables the re-use of Babel’s injected helper code to save on codesize.可以帮我们节省代码 1npm install --save-dev @babel/plugin-transform-runtime @babel/runtime 在.babelrc中配置插件 123\"plugins\": [ \"@babel/plugin-transform-runtime\"] 4.4 添加eslint安装eslint 12npm install eslintnpx eslint --init # 初始化配置文件 12345{ test:/\\.js/, enforce:&apos;pre&apos;, use:&apos;eslint-loader&apos;}, 配置eslint-loader可以实时校验js文件的正确性,pre表示在所有loader执行前执行 5.source-map eval 生成代码 每个模块都被eval执行,每一个打包后的模块后面都增加了包含sourceURL source-map 产生map文件 inline 不会生成独立的 .map文件,会以dataURL形式插入 cheap 忽略打包后的列信息，不使用loader中的sourcemap module 没有列信息，使用loader中的sourcemap(没有列信息) 1devtool:isDev?'cheap-module-eval-source-map':false 每个库中采用的sourcemap方式不一,可以根据自己的需要自行配置 6.resolve解析想实现使用require或是import的时候,可以自动尝试添加扩展名进行匹配 123resolve: { extensions: [\".js\", \".jsx\", \".json\", \".css\", \".ts\", \".tsx\", \".vue\"]}, 7.拷贝静态文件有些时候在打包时希望将一些静态资源文件进行拷贝,可以使用copy-webpack-plugin 安装插件 1npm i copy-webpack-plugin --save-dev 使用拷贝插件 1234const CopyWebpackPlugin = require('copy-webpack-plugin');new CopyWebpackPlugin([ {from:path.resolve('./src/static'),to:path.resolve('./dist')},]) 8.配置代理设置服务端接口 123456const express = require('express');const app = express();app.get('/api/list', (req, res) =&gt; { res.send(['香蕉', '苹果', '橘子']);});app.listen(4000); 安装axios获取数据 1npm install axios --save-dev 配置接口请求 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;div v-for=\"(todo,index) in todos\" :key=\"index\"&gt; {{todo}} &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import axios from 'axios';import {Component ,Vue} from 'vue-property-decorator';@Componentexport default class Todo extends Vue{ public todos:string[] =[]; async mounted(){ let { data } = await axios.get('/api/list'); this.todos = data }}&lt;/script&gt; 配置服务器代理路由 12345proxy: { '/api': { target: 'http://localhost:4000', },}","link":"/2019/11/02/搭建 webpack 配置/"},{"title":"ejs 原理实现","text":"html模板1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% arr.forEach(item =&gt; { %&gt; &lt;li&gt;&lt;%=item%&gt;&lt;/li&gt; &lt;% }) %&gt;&lt;/body&gt;&lt;/html&gt; 使用12345let fs = require('fs')let ejs = require('ejs')let template = fs.readFileSync('上面的模板路径', 'utf8')ejs.render(template, {arr: [1,2,3]}) 渲染结果123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/body&gt;&lt;/html&gt; 思路分析 根据 “&lt;%” 或者 “%&gt;”，代码可以分为三个部分 &lt;%前面的html代码 &lt;% 到 %&gt; 之间的js代码 %&gt;后面的html代码 处理逻辑 处理 &lt;% js代码 %&gt; 之间的代码 将 &lt;% 和 %&gt;之间的js代码取出来 再把提取出来的js代码用一个函数包起来（这里 arr 变量的使用，靠 with 语法实现） 接着将这个函数，通过 new Function 的形式去声明并调用 处理 &lt;%= item %&gt;，即取值的情况 将匹配到的结果，用模板字符串的 ${} 包起来 with 语法：12345678let obj = { name: 1}// 传入一个对象，花括号里面可以直接使用这个对象的属性，而不需要用点去调用with(obj){ console.log(name)} · 模拟实现1234567891011121314151617function render(template, obj) { let html = \"let str = '';\\r\\n\"; html += 'with(obj){\\r\\n' html += \"str += `\" let content = template.replace(/&lt;%([\\s\\S]+?)%&gt;/g, (souceCode, targetCode) =&gt; { return '`\\r\\n' + targetCode + '\\r\\nstr+=`' }) template = template.replace(/&lt;%=([\\s\\S]+?)%&gt;/g, (souceCode, targetCode) =&gt; { return '${' + targetCode + '}'; }) let result = html + content + '`}\\r\\n return str' let fn = new Function('obj', result) return fn(obj)}","link":"/2019/10/30/模板引擎/"},{"title":"进程与集群","text":"进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。 Node特点主线程是单线程的，一个进程只开一个主线程,基于事件驱动的、异步非阻塞I/O，可以应用于高并发场景Nodejs中没有多线程，为了充分利用多核cpu,可以使用子进程实现内核的负载均衡 那我们就要解决以下问题 Node.js 做耗时的计算时候阻塞问题 Node.js如何开启多进程 开发过程中如何实现进程守护 单线程的问题12345678910111213const http = require('http');http.createServer((req,res)=&gt;{ if(req.url === '/sum'){ // 求和 let sum = 0; for(let i = 0 ; i &lt; 10000000000 ;i++){ sum+=i; } res.end(sum+'') }else{ res.end('end'); }}).listen(3000); 访问 /sum 这个路径时，再新建一个浏览器页卡访问 / 会发现新的页卡需要要等待 /sum 路径的逻辑处理好后，才能处理 / 路径的逻辑 spawn 操作进程 适合很大的输出操作时使用 开启进程Node.js 可以通过 child_process 创建子进程 child_process.spawn(） 异步生成子进程 child_process.fork() 产生一个新的Node.js进程，并使用建立的IPC通信通道调用指定的模块，该通道允许在父级和子级之间发送消息。 child_process.exec() 产生一个shell并在该shell中运行命令 child_process.execFile() 无需产生shell spawn1234567891011121314151617181920212223let { spawn } = require(\"child_process\");let path = require(\"path\");// 通过node命令执行sub_process.js文件let childProcess = spawn(\"node\",['sub_process.js'], { cwd: path.resolve(__dirname, \"test\"), // 指定执行文件的父目录 stdio: [0, 1, 2] });// 监控错误childProcess.on(\"error\", function(err) { console.log(err);});// 监听关闭事件childProcess.on(\"close\", function() { console.log(\"close\");});// 监听退出事件childProcess.on(\"exit\", function() { console.log(\"exit\");}); stdio 的 0、1、2 分别对应当前主进程的 process.stdin, process.stdout, process.stderr, 可以写成数字也可以写成属性。还可以写成 inherit ，作用和前面等价，默认写法。也可以设置忽略这些流，设置 stdio: 'inherit' 或者 stdio: ['inherit', 'inherit', 'inherit'] 。 这样就意味着子进程在运行时，使用的 process 是主进程的。 读取子进程的打印结果通过管道的方式通信 1234567891011121314// 主进程let { spawn } = require(\"child_process\");let path = require(\"path\");let childProcess = spawn(\"node\",['sub_process.js'], { cwd: path.resolve(__dirname, \"test\"), stdio: 'pipe' // 等价于 ['pipe', 'pipe', 'pipe']});// 监听标准输出childProcess.stdout.on(\"data\", function(data) { console.log(data);}); 通过管道的方式，监听子进程的可写流，从而可以拿到子进程打印的结果 12345678910// 子进程 test/sub_process.jslet total = 0for (let i = 0; i &lt; 10000000000; i++) { total += i}// 铜鼓process.stdout.write(total + '') // 只能输出字符串或者 buffer 进程通信子进程向主进程发送数据1234567891011121314// 主进程let { spawn } = require(\"child_process\");let path = require(\"path\");let childProcess = spawn(\"node\",['sub_process.js'], { cwd: path.resolve(__dirname, \"test\"), stdio: [0, 1, 2, 'ipc']});// 监听子进程发送过来的数据childProcess.on(\"message\", function(data) { console.log(data);}); stdio 的参数设置比较特殊，可以写成上面那样。还可以把 0、1、2 中的任意一个替换成 ipc 也可以。注意结合 0、1、2 代表的实际意义来决定使用方式。 123456789// 子进程 test/sub_process.jslet total = 0for (let i = 0; i &lt; 10000000000; i++) { total += i}process.send(total) // 向主进程发送意数据类型 主进程向子进程发送数据1childProcess.send(666); 1234567891011let total = 0for (let i = 0; i &lt; 10000000000; i++) { total += i}process.send(total) // 向主进程发送意数据类型process.on('message', (data) =&gt; { console.log(data)}) 注意：上面主进程向子进程通信的逻辑会正确执行，但是主进程和子进程都会保持运行状态。因为子进程在持续监听 message 事件；对于子进程而言，它并不知道主进程什么时候会发送消息过来，从而一直保持监听状态。导致整个程序，即主进程和子进程都维持这运行状态。可以在 message 事件里面，设置 process.exit() 。监听事件被执行后，就关闭主进程。 缺陷上面的进程操作，子进程必须听主进程的；一旦主进程挂了，子进程就会挂。 独立运行的子进程123456789101112// 主进程let { spawn } = require(\"child_process\");let path = require(\"path\");let childProcess = spawn(\"node\",['sub_process.js'], { cwd: path.resolve(__dirname, \"test\"), stdio: 'ingnore', // 忽略子进程的“三流” detached: true // 创建独立的进程});childProcess.unref() // 切断与子进程的关系 123setInterval(() =&gt; { fs.readFileSync('a.txt', '1')}, 1000) 可以在子进程里打印下进程号 process.pid ，方便 kill 解决单线程的问题1234567891011121314151617const http = require('http');const {spawn} = require('child_process');const path = require('path');http.createServer((req,res)=&gt;{ if(req.url === '/sum'){ let cp = spawn('node',['sub_process.js'],{ cwd:path.resolve(__dirname,'test'), stdio:[0, 1, 2,'ipc'] }); cp.on('message',function(total){ res.end('total:'+total); }) }else{ res.end('end ok'); }}).listen(3000); 123456let sum = 0;for(let i = 0 ; i &lt; 10000000000 ;i++){ sum += i;}process.send(sum) child_process 的其它 API 操作进程执行文件 只执行某个文件，不做其他的操作时适合使用。默认使用了 ipc 通信。 1234fork('sum.js',{ cwd:path.resolve(__dirname,'test'), silent:true // true: 管道通信、false: 等价于 spawn 的 stdio 的默认值}); 执行命令 适合数据小于 200k 的操作场景 方式一： 1234 // 不会产生默认的 shell 窗口exec('ls -ll', (err, stdout, stderr) =&gt; { console.log(stdout)}) 方式二： 1234 // 会产生默认的 shell 窗口execFile('ls', ['-ll'], (err, stdout, stderr)=&gt;{ console.log(stdout)}) 集群集群：多个人去实现一个功能分布式：把一个功能拆分成多个，放到不同的地方 实现fork开启多个进程，并同时监听一个服务。当请求到来时，会让空闲的进程去处理。实现负载均衡 12345678910111213141516const {fork} = require('child_process');const cpus = require('os').cpus().length - 1; // 拿到 cpu 核数（当前脚本会占一个进程）const http = require('http');let server = http.createServer((req,res)=&gt;{ res.end('parent:'+process.pid);}).listen(3000);console.log(process.pid) // 当前进程for(let i = 0 ; i &lt; cpus;i++){ let child = fork('server.js'); // server 的名字固定，传入一个http服务，即其他集成需要监听的服务 child.send('server',server);} 12345678// server.jsconst http = require('http')process.on('message', (data, server) =&gt; { http.createServer((req, res) =&gt; { res.end('processPID:' + process.pid) }).listen(server)}) 内置模块123456789101112131415161718192021222324252627const cluster = require('cluster');const cpus = require('os').cpus().length;const http = require('http');if(cluster.isMaster){ cluster.on('exit',function (worker) { // 每当有进程挂掉时 console.log(worker.process.pid); // 打印这个进程的 pid cluster.fork(); // 重启进程 }) for(let i = 0; i&lt; cpus; i++){ cluster.fork(); // 开启进程 } }else{ http.createServer((req,res)=&gt;{ // 模拟错误请求 if(Math.random()&gt;0.5){ aa(); } res.end('process'+process.pid) }).listen(3000); console.log(process.pid);} 原理是给予 fork 实现的，但好处显而易见。上面的程序在第一次运行的时候，isMaster 是 true；监听进程的状态再开启多进程。每开启一个进程(执行一次fork)，这个程序就被自动执行一次；并且每次的 isMaster 是 false。然后在下面的逻辑里，开启多个进程对一个服务的监听。 注意：当前的进程，可以视为守护进程。** pm2pm2可以把你的应用部署到服务器所有的CPU上,实现了多进程管理、监控、及负载均衡 安装pm21234npm install pm2 -g # 安装pm2pm2 start server.js --watch -i max # 启动进程pm2 list # 显示进程状态pm2 kill # 杀死全部进程 1pm2 start npm -- run dev # 启动npm脚本 pm2配置文件1pm2 ecosystem 配置项目自动部署 12345678910111213141516171819202122232425262728module.exports = { apps : [{ name: 'my-project', script: 'server.js', // Options reference: https://pm2.io/doc/en/runtime/reference/ecosystem-file/ args: 'one two', instances: 2, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'development' }, env_production: { NODE_ENV: 'production' } }], deploy : { production : { user : 'root', host : '39.106.14.146', ref : 'origin/master', repo : 'https://github.com/wakeupmypig/pm2-deploy.git', path : '/home', 'post-deploy' : 'npm install &amp;&amp; pm2 reload ecosystem.config.js --env production' } }}; 1pm2 deploy ecosystem.config.js production setup # 执行git clone 上面执行 git clone 的命令去掉 setup，即可启动 pm2","link":"/2019/11/03/进程与集群/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"node","slug":"node","link":"/tags/node/"}],"categories":[{"name":"程序员","slug":"程序员","link":"/categories/程序员/"}]}